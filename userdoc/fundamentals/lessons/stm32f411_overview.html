<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3.3. STM32F411 Overview &mdash; Maasu Internship 4 1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-data-viewer/jsonview.bundle.css?v=f6ef2277" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/libs/html/datatables.min.css?v=4b4fd840" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/common.css?v=bd9ab754" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/layouts.css?v=448c382f" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/styles.css?v=6c8eb985" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/modern.css?v=ffa536d2" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=29a6c3e3"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/sphinx-data-viewer/jsonview.bundle.js?v=18cd53c5"></script>
        <script src="../../../_static/sphinx-data-viewer/jsonview_loader.js?v=f7ff7e7d"></script>
        <script src="../../../_static/sphinx-needs/libs/html/datatables.min.js?v=8a4aee21"></script>
        <script src="../../../_static/sphinx-needs/libs/html/datatables_loader.js?v=a2cae175"></script>
        <script src="../../../_static/sphinx-needs/libs/html/sphinx_needs_collapse.js?v=f783d6a5"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="3.4. The Build Process" href="build_process.html" />
    <link rel="prev" title="3.2. SDLC V-Model" href="vmodel.html" />
<link href="../../../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Maasu Internship 4
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../introduction/introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../project/project.html">2. Project Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../fundamentals.html">3. Fundamentals</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">3.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="vmodel.html">3.2. SDLC V-Model</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">3.3. STM32F411 Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#features">3.3.1. Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="#block-diagram">3.3.2. Block Diagram</a></li>
<li class="toctree-l3"><a class="reference internal" href="#usart">3.3.3. USART</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#serial-communication-explained">3.3.3.1. Serial Communication Explained</a></li>
<li class="toctree-l4"><a class="reference internal" href="#key-concepts">3.3.3.2. Key Concepts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuring-usart-on-stm32">3.3.3.3. Configuring USART on STM32</a></li>
<li class="toctree-l4"><a class="reference internal" href="#setting-usart-configuration">3.3.3.4. Setting USART Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-transmission">3.3.3.5. Data Transmission</a></li>
<li class="toctree-l4"><a class="reference internal" href="#practical-application">3.3.3.6. Practical Application</a></li>
<li class="toctree-l4"><a class="reference internal" href="#register-definitions">3.3.3.7. Register Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#summary">3.3.3.8. Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="#resources">3.3.3.9. Resources</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#clock-initialization">3.3.4. Clock Initialization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">3.3.4.1. Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#key-terms-and-abbreviations">3.3.4.2. Key Terms and Abbreviations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-pll-configuration">3.3.4.3. Example PLL Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#why-is-clock-initialization-needed">3.3.4.4. Why is Clock Initialization Needed?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application-in-our-case">3.3.4.5. Application in Our Case</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation-details">3.3.4.6. Implementation Details</a></li>
<li class="toctree-l4"><a class="reference internal" href="#conclusion">3.3.4.7. Conclusion</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pwm-initialization-frequency-setting-and-duty-cycle-configuration-on-stm32-microcontrollers">3.3.5. PWM Initialization, Frequency Setting, and Duty Cycle Configuration on STM32 Microcontrollers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#initialization-process">3.3.5.1. Initialization Process</a></li>
<li class="toctree-l4"><a class="reference internal" href="#setting-pwm-frequency">3.3.5.2. Setting PWM Frequency</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuring-duty-cycle">3.3.5.3. Configuring Duty Cycle</a></li>
<li class="toctree-l4"><a class="reference internal" href="#enabling-and-disabling-pwm-output">3.3.5.4. Enabling and Disabling PWM Output</a></li>
<li class="toctree-l4"><a class="reference internal" href="#center-aligned-and-edge-aligned-modes">3.3.5.5. Center-Aligned and Edge-Aligned Modes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-for-setting-frequency-and-duty-cycle">3.3.5.6. Examples for Setting Frequency and Duty Cycle</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id1">3.3.5.7. Key Concepts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">3.3.5.8. Summary</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="build_process.html">3.4. The Build Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="cmsis_register.html">3.5. CMSIS and Register Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="protocols.html">3.6. Communication Protocols</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../lessons/lessons.html">4. Lessons</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../environment_setup/environment_setup.html">5. Development Environment Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../requirements/requirements.html">6. Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../architecture/architecture.html">7. Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../implementation/implementation.html">8. Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../testing/testing.html">9. Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faqs/faqs.html">10. Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary/glossary.html">11. Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Maasu Internship 4</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../fundamentals.html"><span class="section-number">3. </span>Fundamentals</a></li>
      <li class="breadcrumb-item active"><span class="section-number">3.3. </span>STM32F411 Overview</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/userdoc/fundamentals/lessons/stm32f411_overview.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="stm32f411-overview">
<h1><span class="section-number">3.3. </span>STM32F411 Overview<a class="headerlink" href="#stm32f411-overview" title="Link to this heading"></a></h1>
<p>The STM32F411 microcontrollers are part of the STM32 Dynamic Efficiency™ lines. These devices represent the entry level to the High Performance F4 Series, offering a balanced combination of dynamic power consumption (in run mode) and processing performance. They integrate a rich set of features in compact 3 x 3 mm packages.</p>
<p>The STM32F411 MCUs are powered by a Cortex®-M4 core with floating point unit, operating at 100 MHz, and achieve exceptionally low power consumption in both run and stop modes. A key feature, Batch Acquisition Mode (BAM), optimizes power usage during data batching. This mode enables efficient data exchange through communication peripherals while keeping the CPU and other parts of the device in power-saving modes.</p>
<section id="features">
<h2><span class="section-number">3.3.1. </span>Features<a class="headerlink" href="#features" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>Includes ST state-of-the-art patented technology</p></li>
<li><p>Dynamic efficiency line with BAM (Batch acquisition mode)</p></li>
<li><p>Operating voltage: 1.7 V to 3.6 V</p></li>
<li><p>Temperature range: -40°C to 85/105/125 °C</p></li>
</ul>
<p><strong>Core</strong></p>
<ul class="simple">
<li><p>Arm® 32-bit Cortex®-M4 CPU with FPU</p></li>
<li><p>Adaptive real-time accelerator (ART Accelerator) for 0-wait state execution from flash memory</p></li>
<li><p>Operating frequency up to 100 MHz</p></li>
<li><p>Memory protection unit</p></li>
<li><p>125 DMIPS/1.25 DMIPS/MHz (Dhrystone 2.1)</p></li>
<li><p>DSP instructions</p></li>
</ul>
<p><strong>Memories</strong></p>
<ul class="simple">
<li><p>Up to 512 Kbytes of flash memory</p></li>
<li><p>128 Kbytes of SRAM</p></li>
</ul>
<p><strong>Clock, Reset, and Supply Management</strong></p>
<ul class="simple">
<li><p>Wide range application supply and I/O voltage: 1.7 V to 3.6 V</p></li>
<li><p>Power-on reset (POR), power-down reset (PDR), power voltage detector (PVD), and brown-out reset (BOR)</p></li>
<li><p>4-to-26 MHz crystal oscillator</p></li>
<li><p>Internal 16 MHz factory-trimmed RC oscillator</p></li>
<li><p>32 kHz oscillator for RTC with calibration</p></li>
<li><p>Internal 32 kHz RC oscillator with calibration</p></li>
</ul>
<p><strong>Power Consumption</strong></p>
<ul class="simple">
<li><p>Run mode: 100 μA/MHz (peripheral off)</p></li>
<li><p>Stop mode (Flash in Stop mode, fast wakeup time): 42 μA typical at 25 °C; 65 μA max at 25 °C</p></li>
<li><p>Stop mode (Flash in Deep power down mode, slow wakeup time): down to 9 μA at 25 °C; 28 μA max at 25 °C</p></li>
<li><p>Standby: 1.8 μA at 25 °C / 1.7 V without RTC; 11 μA at 85 °C at 1.7 V</p></li>
<li><p>VBAT supply for RTC: 1 μA at 25 °C</p></li>
</ul>
<p><strong>Analog Features</strong></p>
<ul class="simple">
<li><p>1x12-bit, 2.4 MSPS A/D converter: up to 16 channels</p></li>
</ul>
<p><strong>DMA</strong></p>
<ul class="simple">
<li><p>General-purpose DMA: 16-stream DMA controllers with FIFOs and burst support</p></li>
</ul>
<p><strong>Timers</strong></p>
<ul class="simple">
<li><p>Up to 11 timers: up to six 16-bit, two 32-bit timers up to 100 MHz</p></li>
<li><p>Each timer with up to four IC/OC/PWM or pulse counter and quadrature (incremental) encoder input</p></li>
<li><p>Two watchdog timers (independent and window)</p></li>
<li><p>SysTick timer</p></li>
</ul>
<p><strong>Debugging</strong></p>
<ul class="simple">
<li><p>Serial wire debug (SWD) &amp; JTAG interfaces</p></li>
<li><p>Cortex®-M4 Embedded Trace Macrocell™ (ETM)</p></li>
</ul>
<p><strong>I/O Ports</strong></p>
<ul class="simple">
<li><p>Up to 81 I/O ports with interrupt capability</p></li>
<li><p>Up to 78 fast I/Os up to 100 MHz</p></li>
<li><p>Up to 77 5 V-tolerant I/Os</p></li>
</ul>
<p><strong>Communication Interfaces</strong></p>
<ul class="simple">
<li><p>Up to 13 communication interfaces:
- Up to 3 x I2C interfaces (SMBus/PMBus)
- Up to 3 USARTs (2 x 12.5 Mbit/s, 1 x 6.25 Mbit/s)
- ISO 7816 interface, LIN, IrDA, modem control
- Up to 5 SPI/I2Ss (up to 50 Mbit/s)
- SPI2 and SPI3 with muxed full-duplex I2S for audio class accuracy via internal audio PLL or external clock
- SDIO interface (SD/MMC/eMMC)
- USB 2.0 full-speed device/host/OTG controller with on-chip PHY</p></li>
</ul>
<p><strong>Other Features</strong></p>
<ul class="simple">
<li><p>CRC calculation unit</p></li>
<li><p>96-bit unique ID</p></li>
<li><p>RTC: subsecond accuracy, hardware calendar</p></li>
</ul>
<p><strong>Compliance</strong></p>
<ul class="simple">
<li><p>All packages are ECOPACK2 compliant</p></li>
</ul>
</section>
<section id="block-diagram">
<h2><span class="section-number">3.3.2. </span>Block Diagram<a class="headerlink" href="#block-diagram" title="Link to this heading"></a></h2>
<a class="reference internal image-reference" href="../../../_images/stm32f411diagram2.svg"><img alt="../../../_images/stm32f411diagram2.svg" src="../../../_images/stm32f411diagram2.svg" width="1000em" /></a>
</section>
<section id="usart">
<h2><span class="section-number">3.3.3. </span>USART<a class="headerlink" href="#usart" title="Link to this heading"></a></h2>
<p>USART (Universal Synchronous/Asynchronous Receiver/Transmitter) is a vital hardware component in microcontrollers, facilitating serial communication between devices. Unlike UART, which is asynchronous only, USART supports both synchronous and asynchronous modes. This guide focuses on asynchronous serial communication using USART on STM32 microcontrollers, particularly the STM32F411 series.</p>
<section id="serial-communication-explained">
<h3><span class="section-number">3.3.3.1. </span>Serial Communication Explained<a class="headerlink" href="#serial-communication-explained" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Asynchronous Serial Communication</strong>: Data is transmitted sequentially, one bit at a time, over a single data line without requiring a clock line. It uses start and stop bits to indicate the beginning and end of transmission, and may include a parity bit for error detection.</p></li>
<li><p><strong>Synchronous Serial Communication</strong>: Involves both data and clock lines, where the microcontroller sends a clock signal to synchronize communication. This eliminates the need for start, stop, and parity bits, making synchronous communication faster and more efficient.</p></li>
</ul>
</section>
<section id="key-concepts">
<h3><span class="section-number">3.3.3.2. </span>Key Concepts<a class="headerlink" href="#key-concepts" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Sample and Sample Rate</strong>: A sample refers to a single piece of data being transmitted. The sample rate is the number of samples taken per second.</p></li>
<li><p><strong>Oversampling</strong>: Involves sampling at a higher rate than the minimum required to improve accuracy and simplify filtering. The default oversampling rate is 16.</p></li>
<li><p><strong>Baud Rate</strong>: Determines the speed at which data bits are transmitted. Correct baud rate configuration is essential for smooth communication.</p></li>
</ul>
</section>
<section id="configuring-usart-on-stm32">
<h3><span class="section-number">3.3.3.3. </span>Configuring USART on STM32<a class="headerlink" href="#configuring-usart-on-stm32" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p><strong>Enabling the Clock</strong>: Enable the USART clock by setting the appropriate bits in the RCC (Reset and Clock Control) register.</p></li>
<li><p><strong>Configuring GPIO Pins</strong>: Each USART peripheral uses specific GPIO pins for transmission (TX) and reception (RX). Set these pins to Alternate Function mode and map them to the appropriate Alternate Function (AF). The pin configurations for different USART peripherals are as follows:</p></li>
</ol>
<ul class="simple">
<li><dl class="simple">
<dt><strong>USART1</strong>:</dt><dd><ul>
<li><p>TX: PA9 or PB6</p></li>
<li><p>RX: PA10 or PB7</p></li>
<li><p>Alternate Function: AF7</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>USART2</strong>:</dt><dd><ul>
<li><p>TX: PA2 or PD5</p></li>
<li><p>RX: PA3 or PD6</p></li>
<li><p>Alternate Function: AF7</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>USART6</strong>:</dt><dd><ul>
<li><p>TX: PC6 or PG14</p></li>
<li><p>RX: PC7 or PG9</p></li>
<li><p>Alternate Function: AF8</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
<section id="setting-usart-configuration">
<h3><span class="section-number">3.3.3.4. </span>Setting USART Configuration<a class="headerlink" href="#setting-usart-configuration" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Oversampling and Baud Rate</strong>:</p></li>
<li><dl class="simple">
<dt>Calculate the baud rate using the formula:</dt><dd><ul>
<li><p>For oversampling by 16: USARTDIV = Fck / Baudrate</p></li>
<li><p>For oversampling by 8: USARTDIV = Fck / (Baudrate * 2)</p></li>
<li><p>Here, Fck is the clock frequency of the bus (50 MHz or 50,000,000 Hz), and the desired baud rate is 115200.</p></li>
<li><p>Add 0.5f for rounding: USARTDIV = (Fck / (Baudrate * 2)) + 0.5f</p></li>
<li><p>Write the calculated value to the BRR (Baud Rate Register): USART2-&gt;BRR</p></li>
</ul>
</dd>
</dl>
</li>
<li><p><strong>Mode Configuration</strong>:
- Configure USART to operate in RX only, TX only, or both RX and TX modes by setting the appropriate bits in the USART control register (CR1).
- Enable the USART by setting the UE (USART Enable) bit in the CR1 register.
- Set the TE (Transmitter Enable) and RE (Receiver Enable) bits in the CR1 register to enable transmission and reception.</p></li>
</ul>
</section>
<section id="data-transmission">
<h3><span class="section-number">3.3.3.5. </span>Data Transmission<a class="headerlink" href="#data-transmission" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Transmitting Data</strong>:
1. Wait for the Transmit Data Register Empty (TXE) flag by checking the status register (SR).
2. Write data to the Data Register (DR) for transmission.</p></li>
<li><p><strong>Transmitting a Buffer</strong>: Write each byte to the data register one by one, ensuring the transmit data register is empty before writing the next byte.</p></li>
</ul>
</section>
<section id="practical-application">
<h3><span class="section-number">3.3.3.6. </span>Practical Application<a class="headerlink" href="#practical-application" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Configuration Example</strong>:
- Use USART2 with PA2 (TX) and PA4 (RX) pins.
- Configure for asynchronous communication with a baud rate of 115200 and oversampling by 16.</p></li>
<li><p><strong>Usage in Main Function</strong>:
1. Initialize USART: Set up the USART mode, oversampling, and baud rate.
2. Enable USART: Enable the USART for communication.
3. Transmit Data: Use functions to send data bytes or buffers via USART.</p></li>
</ul>
</section>
<section id="register-definitions">
<h3><span class="section-number">3.3.3.7. </span>Register Definitions<a class="headerlink" href="#register-definitions" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>RCC</strong>: Reset and Clock Control, used to enable the clock for USART.</p></li>
<li><p><strong>CR1</strong>: Control Register 1, used to configure USART settings like enabling USART, transmitter, and receiver.
- UE: USART Enable bit in CR1.
- TE: Transmitter Enable bit in CR1.
- RE: Receiver Enable bit in CR1.</p></li>
<li><p><strong>BRR</strong>: Baud Rate Register, used to set the baud rate for communication.</p></li>
<li><p><strong>DR</strong>: Data Register, used to hold data to be transmitted.</p></li>
<li><p><strong>SR</strong>: Status Register, used to check the status of the USART, including the TXE (Transmit Data Register Empty) flag.</p></li>
</ul>
</section>
<section id="summary">
<h3><span class="section-number">3.3.3.8. </span>Summary<a class="headerlink" href="#summary" title="Link to this heading"></a></h3>
<p>Understanding and configuring USART is essential for reliable serial communication in embedded applications. Proper initialization, pin configuration, and data transmission ensure smooth and efficient communication between devices.</p>
</section>
<section id="resources">
<h3><span class="section-number">3.3.3.9. </span>Resources<a class="headerlink" href="#resources" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>STM32F411 Datasheet</p></li>
<li><p>STM32F411 Reference Manual</p></li>
<li><p>Example code on GitHub: <a class="reference external" href="https://github.com/MootSeeker/STM32_Embedded_CPP">STM32 USART Example</a></p></li>
</ul>
</section>
</section>
<section id="clock-initialization">
<h2><span class="section-number">3.3.4. </span>Clock Initialization<a class="headerlink" href="#clock-initialization" title="Link to this heading"></a></h2>
<section id="introduction">
<h3><span class="section-number">3.3.4.1. </span>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h3>
<p>Clock initialization is a crucial step in setting up the STM32 microcontroller for efficient and accurate operation. This document outlines the key concepts, terms, and processes involved in clock initialization, including relevant registers and their configurations. Understanding these components is essential for optimizing the performance and power consumption of the microcontroller.</p>
</section>
<section id="key-terms-and-abbreviations">
<h3><span class="section-number">3.3.4.2. </span>Key Terms and Abbreviations<a class="headerlink" href="#key-terms-and-abbreviations" title="Link to this heading"></a></h3>
<p><strong>RCC (Reset and Clock Control)</strong></p>
<ul class="simple">
<li><p><strong>RCC</strong>: A peripheral that manages the reset and clock control for the STM32 microcontroller. It configures the system clocks and controls the reset circuitry.</p></li>
</ul>
<p><strong>Registers</strong></p>
<ul class="simple">
<li><p><strong>CR (Control Register)</strong>: A register within the RCC that controls the clock sources and oscillators.</p></li>
<li><p><strong>APB1ENR (APB1 Peripheral Clock Enable Register)</strong>: A register within the RCC that enables or disables the clock for peripherals connected to the APB1 bus.</p></li>
</ul>
<p><strong>Clock Sources</strong></p>
<ul class="simple">
<li><p><strong>HSI (High-Speed Internal)</strong>: An internal clock source typically running at 8 MHz.</p></li>
<li><p><strong>HSE (High-Speed External)</strong>: An external clock source that can provide a more accurate clock signal.</p></li>
<li><p><strong>LSI (Low-Speed Internal)</strong>: An internal low-speed clock source used for low-power applications.</p></li>
<li><p><strong>LSE (Low-Speed External)</strong>: An external low-speed clock source, often used for RTC (Real-Time Clock) functionality.</p></li>
</ul>
<p><strong>Bits and Configurations</strong></p>
<ul class="simple">
<li><p><strong>HSEBYP</strong>: A bit in the CR that allows bypassing the HSE oscillator with an external clock.</p></li>
<li><p><strong>HSEON</strong>: A bit in the CR that enables the high-speed external oscillator.</p></li>
<li><p><strong>HSERDY</strong>: A status bit in the CR that indicates if the HSE oscillator is stable and ready for use.</p></li>
</ul>
<p><strong>Power Control</strong></p>
<ul class="simple">
<li><p><strong>PWREN</strong>: A bit in the APB1ENR that enables the clock for the power control module.</p></li>
<li><p><strong>VOS (Voltage Scaling)</strong>: A bit in the PWR_CR (Power Control Register) that controls the voltage and performance levels of the microcontroller.
- <strong>Bit 14</strong>: VOS_0: Scale 0 - Highest performance, highest voltage.
- <strong>Bit 15</strong>: VOS_1: Scale 1 - Medium performance, medium voltage.</p></li>
</ul>
<p><strong>Flash Configuration</strong></p>
<ul class="simple">
<li><p><strong>FLASH_ACR_LATENCY</strong>: Configures the number of wait states for the flash memory. For example, setting it to 3 wait states (3WS) allows the flash to operate correctly at higher clock speeds (90 to 100 MHz).</p></li>
</ul>
<p><strong>PLL (Phase-Locked Loop) Configuration</strong></p>
<ul class="simple">
<li><p><strong>PLLCFGR (PLL Configuration Register)</strong>: Configures the multipliers and dividers for the PLL to achieve the desired clock frequency.
- <strong>PLLM</strong>: Multiplier for the main clock (HCLK).
- <strong>PLLN</strong>: Multiplier for the PLL clock output frequency.
- <strong>PLLP</strong>: Prescaler division factor for HCLK. Also includes PLLQ and PLLI2S for USB and I2S respectively.</p></li>
</ul>
</section>
<section id="example-pll-configuration">
<h3><span class="section-number">3.3.4.3. </span>Example PLL Configuration<a class="headerlink" href="#example-pll-configuration" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>RCC_PLLCFGR_PLLM</strong>: Bit mask for PLLM in the PLLCFGR register.</p></li>
<li><p><strong>RCC_PLLCFGR_PLLM_Pos</strong>: Position of PLLM bits in the PLLCFGR register.</p></li>
</ul>
<p>The formula to calculate the clock is:</p>
<p>f(VCO clock) = f(PLL clock input) × (PLLN / PLLM)
f(PLL general clock output) = f(VCO clock) / PLLP</p>
</section>
<section id="why-is-clock-initialization-needed">
<h3><span class="section-number">3.3.4.4. </span>Why is Clock Initialization Needed?<a class="headerlink" href="#why-is-clock-initialization-needed" title="Link to this heading"></a></h3>
<p>Clock initialization is vital for several reasons:</p>
<ol class="arabic simple">
<li><p><strong>Accuracy</strong>: Ensures the microcontroller operates at the correct frequency, which is crucial for timing-sensitive applications.</p></li>
<li><p><strong>Performance</strong>: Allows the microcontroller to achieve optimal performance by configuring the clock sources and PLL correctly.</p></li>
<li><p><strong>Power Efficiency</strong>: Proper clock configuration can help reduce power consumption, especially in low-power applications.</p></li>
</ol>
</section>
<section id="application-in-our-case">
<h3><span class="section-number">3.3.4.5. </span>Application in Our Case<a class="headerlink" href="#application-in-our-case" title="Link to this heading"></a></h3>
<p>In our specific application, clock initialization is used to set up the STM32 microcontroller to operate at 100 MHz using an external 8 MHz clock source. This setup is achieved by configuring the PLL and other relevant registers.</p>
</section>
<section id="implementation-details">
<h3><span class="section-number">3.3.4.6. </span>Implementation Details<a class="headerlink" href="#implementation-details" title="Link to this heading"></a></h3>
<p>Following the suggestion from Muhamed, I have separated the declaration and implementation of the clock initialization function into different files for better code readability and maintenance. To have a successful compilation, I also added clock_init to the makefile.</p>
<p>Additionally, I have corrected the bit-shifting for PLLP by adding _Pos, which was missing in the original code.</p>
</section>
<section id="conclusion">
<h3><span class="section-number">3.3.4.7. </span>Conclusion<a class="headerlink" href="#conclusion" title="Link to this heading"></a></h3>
<p>Clock initialization in STM32 microcontrollers is essential for ensuring accurate operation, optimal performance, and power efficiency. By understanding and properly configuring the relevant registers and bits, we can tailor the microcontroller’s operation to meet the specific needs of our application. This process involves selecting appropriate clock sources, setting voltage scales, configuring flash memory wait states, and tuning the PLL parameters to achieve the desired clock frequency. Proper clock initialization lays the foundation for reliable and efficient microcontroller performance.</p>
</section>
</section>
<section id="pwm-initialization-frequency-setting-and-duty-cycle-configuration-on-stm32-microcontrollers">
<h2><span class="section-number">3.3.5. </span>PWM Initialization, Frequency Setting, and Duty Cycle Configuration on STM32 Microcontrollers<a class="headerlink" href="#pwm-initialization-frequency-setting-and-duty-cycle-configuration-on-stm32-microcontrollers" title="Link to this heading"></a></h2>
<p>This document provides a detailed explanation of how to initialize, set the frequency, and configure the duty cycle for Pulse Width Modulation (PWM) on STM32 microcontrollers using a timer. The Pwm class handles the configuration and management of PWM signals.</p>
<table class="docutils align-default" id="id3">
<caption><span class="caption-text">PWM Output Capabilities of STM32 Timers</span><a class="headerlink" href="#id3" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>TIMER</p></th>
<th class="head"><p>BUS</p></th>
<th class="head"><p>CHANNEL</p></th>
<th class="head"><p>PINS</p></th>
<th class="head"><p>AF</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>TIM1</p></td>
<td><p>APB2 (100 MHz)</p></td>
<td><p>1</p></td>
<td><p>PA8, PE9</p></td>
<td><p>AF01</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>2</p></td>
<td><p>PA9, PE11</p></td>
<td></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>3</p></td>
<td><p>PA10, PE13</p></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>4</p></td>
<td><p>PA11, PE14</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>TIM2</p></td>
<td><p>APB1 (50 MHz)</p></td>
<td><p>1</p></td>
<td><p>PA0, PA5</p></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>2</p></td>
<td><p>PA1, PB3</p></td>
<td></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>3</p></td>
<td><p>PA2, PB10</p></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>4</p></td>
<td><p>PA3, PB11</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>TIM3</p></td>
<td></td>
<td><p>1</p></td>
<td><p>PA6, PB4</p></td>
<td><p>AF02</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>2</p></td>
<td><p>PA7, PB5</p></td>
<td></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>3</p></td>
<td><p>PB0, PC8</p></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>4</p></td>
<td><p>PB1, PC9</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>TIM4</p></td>
<td></td>
<td><p>1</p></td>
<td><p>PB6, PD12</p></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>2</p></td>
<td><p>PB7, PD13</p></td>
<td></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>3</p></td>
<td><p>PB8, PD14</p></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>4</p></td>
<td><p>PB9, PD15</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>TIM5</p></td>
<td></td>
<td><p>1</p></td>
<td><p>PA0</p></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>2</p></td>
<td><p>PA1</p></td>
<td></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>3</p></td>
<td><p>PA2</p></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>4</p></td>
<td><p>PA3</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>TIM9</p></td>
<td><p>APB2 (100 MHz)</p></td>
<td><p>1</p></td>
<td><p>PA2</p></td>
<td><p>AF03</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>2</p></td>
<td><p>PA3</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>TIM10</p></td>
<td></td>
<td><p>1</p></td>
<td><p>PB8</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>TIM11</p></td>
<td></td>
<td><p>1</p></td>
<td><p>PB9</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>This table outlines the PWM output capabilities of STM32 timers, detailing each timer’s bus, channel, pins, and alternate functions (AF). It helps identify which pins are available for PWM and their corresponding alternate functions for each timer. Since we are using pins PA2, PA3, PA8, PA9, PC6 and PC7 for our USART initialization, we must avoid those pins when setting up our PWM.</p>
<section id="initialization-process">
<h3><span class="section-number">3.3.5.1. </span>Initialization Process<a class="headerlink" href="#initialization-process" title="Link to this heading"></a></h3>
<ol class="arabic">
<li><p>Clock Enablement</p>
<p>To start setting up PWM, the first step is to enable the clock for the specific timer you’re using. This ensures the timer gets power and can work properly. Each timer in the STM32 microcontroller needs its corresponding clock to be turned on through the RCC (Reset and Clock Control) registers. The enableClock() function takes care of this by checking which timer (like TIM1, TIM2, etc.) is being used and then setting the right bit in the RCC register to activate the clock for that timer. This step is essential for the timer to function correctly.</p>
</li>
<li><p>GPIO Configuration</p>
<p>The configureGpio() function handles setting up the correct GPIO pin for PWM output based on the timer and channel you’re working with. It selects the appropriate port and pin from the STM32 datasheet, making sure that the pin isn’t being used by other peripherals. The function then configures the pin as an alternate function and sets the correct alternate function based on the timer, ensuring the PWM output works as expected. This process ensures that the pin is correctly mapped to the timer as shown in the table.</p>
</li>
<li><p>PWM Mode Configuration</p>
<p>The configurePwmMode() function sets the PWM mode for a particular timer channel using the PwmMode enumeration. It first clears any previous mode settings in the capture/compare mode register (CCMR) for the selected channel and then applies the new PWM mode by setting the appropriate bits. Additionally, it enables the output for that channel in the capture/compare enable register (CCER), ensuring the timer runs in the desired PWM mode. The PwmMode enum helps define different PWM modes for various channels, making it easy to choose the mode you need.</p>
</li>
</ol>
</section>
<section id="setting-pwm-frequency">
<h3><span class="section-number">3.3.5.2. </span>Setting PWM Frequency<a class="headerlink" href="#setting-pwm-frequency" title="Link to this heading"></a></h3>
<ol class="arabic">
<li><p>Determining Timer Clock Frequency</p>
<p>The clock frequency for each timer depends on its APB bus. Timers on the APB1 bus, like TIM2, TIM3, TIM4, and TIM5, run at 50 MHz, while those on the APB2 bus, such as TIM1, TIM9, TIM10, and TIM11, run at 100 MHz.</p>
</li>
<li><p>Calculating Prescaler and Auto-Reload Register (ARR) Values</p>
<p>The prescaler and ARR values are determined based on the desired PWM frequency. The prescaler divides the timer clock to lower frequencies, and the ARR defines the PWM signal period. Here’s the approach:</p>
<ul class="simple">
<li><p>Calculate the Period:
Period = Timer Clock / Frequency</p></li>
<li><p>Adjust Prescaler:
If the calculated period exceeds the maximum value for the prescaler (65535), increment the prescaler value to reduce the period until it fits within the 16-bit range.</p></li>
<li><p>Set ARR Value:
Based on the adjusted prescaler, recalculate the timer clock and then compute the ARR value using:
ARR = (Timer Clock / (Frequency * Prescaler)) - 1</p></li>
<li><p>Update Registers:
Write the computed prescaler and ARR values to the corresponding timer registers.</p></li>
</ul>
</li>
</ol>
</section>
<section id="configuring-duty-cycle">
<h3><span class="section-number">3.3.5.3. </span>Configuring Duty Cycle<a class="headerlink" href="#configuring-duty-cycle" title="Link to this heading"></a></h3>
<ol class="arabic">
<li><p>Validating Duty Cycle Range</p>
<p>The duty cycle, expressed as a percentage (0-100%), indicates the proportion of time the PWM signal is high within each period. For example, a 25% duty cycle means the signal is high for 25% of the PWM period. This percentage affects output strength: a 25% duty cycle on a motor means it runs at 25% of its maximum speed, and on an LED, it shines at 25% brightness.</p>
</li>
<li><p>Calculating CCR Value</p>
<p>To set the duty cycle, calculate the Capture/Compare Register (CCR) value with the formula:
CCR = (Duty Cycle * (ARR + 1)) / 100</p>
<ul class="simple">
<li><p>Write to Register:
Based on the selected channel, write the computed CCR value to the appropriate CCR register (CCR1, CCR2, CCR3, or CCR4).</p></li>
</ul>
</li>
</ol>
</section>
<section id="enabling-and-disabling-pwm-output">
<h3><span class="section-number">3.3.5.4. </span>Enabling and Disabling PWM Output<a class="headerlink" href="#enabling-and-disabling-pwm-output" title="Link to this heading"></a></h3>
<ol class="arabic">
<li><p>Enabling PWM</p>
<p>To start the PWM signal, the timer needs to be enabled. This is done by setting the appropriate control register bits. Once enabled, the timer begins generating the PWM signal based on the configured frequency and duty cycle.</p>
</li>
<li><p>Disabling PWM</p>
<p>To stop the PWM signal, the timer can be disabled by clearing the control register bits. This halts the timer operation and stops the PWM output.</p>
</li>
</ol>
</section>
<section id="center-aligned-and-edge-aligned-modes">
<h3><span class="section-number">3.3.5.5. </span>Center-Aligned and Edge-Aligned Modes<a class="headerlink" href="#center-aligned-and-edge-aligned-modes" title="Link to this heading"></a></h3>
<ol class="arabic">
<li><p>Center-Aligned Mode</p>
<p>In center-aligned mode, the timer counts up and down within the PWM period, providing a symmetric waveform around the center of the period. This mode can be configured by setting the appropriate bits in the timer control register.</p>
</li>
<li><p>Edge-Aligned Mode</p>
<p>In edge-aligned mode, the timer counts up from zero to the ARR value and then resets, producing a waveform with transitions at the edges of the period. This is the default mode for most PWM configurations and is also set through the timer control register.</p>
</li>
</ol>
</section>
<section id="examples-for-setting-frequency-and-duty-cycle">
<h3><span class="section-number">3.3.5.6. </span>Examples for Setting Frequency and Duty Cycle<a class="headerlink" href="#examples-for-setting-frequency-and-duty-cycle" title="Link to this heading"></a></h3>
<p>Let’s say we want to configure PWM using TIM3 channel 3 at a frequency of 20 kHz and a duty cycle of 25%:</p>
<ol class="arabic">
<li><p>Enable Clock</p>
<p>We enable the clock for the specified timer using RCC_APB1ENR_TIM3EN. TIM3 is located on APB1, so its clock is 50 MHz.</p>
</li>
<li><p>Configure GPIO Port</p>
<p>Since we are using TIM3 channel 3, we will use pin PB0 on port GPIOB. We set the alternate function to AF2, because of TIM3.</p>
</li>
<li><p>Set PWM Mode</p>
<p>We are using PWM Mode 1 for channel 3:
PWM_MODE_1_Ch3 = (TIM_CCMR2_OC3M_1 | TIM_CCMR2_OC3M_2 | TIM_CCMR2_OC3PE)
We first clear the bits in the CCMR2 register for channel 3, then set its value as shown above. By setting TIM_CCMR2_OC3PE, we enable the preload register for this channel, allowing for stable PWM signals and avoiding glitches when changing the duty cycle.</p>
<ul class="simple">
<li><p>PWM Mode 1: Requires setting both OC3M_1 and OC3M_2 to configure the timer to output high when the counter is less than CCR3 and low otherwise.</p></li>
<li><p>Preload Enable (OC3PE): Ensures that changes to the compare value (CCR3) are synchronized with the timer counter, avoiding glitches in the PWM signal.</p></li>
</ul>
</li>
<li><p>Set Frequency</p>
<p>For TIM3, with a clock of 50 MHz:
Period = Timer Clock / Frequency = 50000000 / 20000 = 2500
Since 2500 is less than 65535, the prescaler is set to 0. Therefore, the PSC register is set to 0, and the ARR register is set to Period - 1.</p>
<ul class="simple">
<li><p>ARR Register: Sets the period of the timer. The timer counts from 0 to the value in ARR. When the timer reaches the value in ARR, it resets to 0 and starts counting again. Therefore, the actual number of counts the timer performs is ARR + 1 because the timer starts from 0.</p></li>
</ul>
</li>
<li><p>Calculate Duty Cycle</p>
<p>For a duty cycle of 25%:
CCR = (25 * (ARR + 1)) / 100 = (25 * 2500) / 100 = 625
Write the CCR value to the appropriate CCR register.</p>
</li>
<li><p>Enable PWM</p>
<p>Enable the PWM by setting the TIM_CR1_CEN register. If necessary, configure the mode to center-aligned or edge-aligned.</p>
</li>
</ol>
</section>
<section id="id1">
<h3><span class="section-number">3.3.5.7. </span>Key Concepts<a class="headerlink" href="#id1" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Frequency</strong>
* The number of PWM cycles per second.
* Units: Hertz (Hz)
* Formula: Frequency = 1 / Period</p></li>
<li><p><strong>Timer Clock</strong>
* The frequency at which the timer increments, derived from the system clock.
* Example: 50 MHz for APB1 timers, 100 MHz for APB2 timers.</p></li>
<li><p><strong>Duty Cycle</strong>
* The percentage of time the PWM signal is high.
* Units: Percentage (%)
* Formula: Duty Cycle = (High Time / Period) * 100</p></li>
<li><p><strong>CCMR1 (Capture/Compare Mode Register 1)</strong>
* Configures Timer channels 1 and 2 modes, including PWM and input capture.</p></li>
<li><p><strong>CCMR2 (Capture/Compare Mode Register 2)</strong>
* Configures Timer channels 3 and 4 modes, similar to CCMR1.</p></li>
<li><p><strong>OC1M (Output Compare 1 Mode)</strong>
* Sets the behavior of Timer channel 1’s output when it matches the CCR1 value.</p></li>
<li><p><strong>OC1PE (Output Compare 1 Preload Enable)</strong>
* Enables buffering of the compare value for Timer channel 1 to prevent glitches.</p></li>
<li><p><strong>RCC (Reset and Clock Control)</strong>
* Manages clocks and resets for system peripherals.</p></li>
<li><p><strong>CCER (Capture/Compare Enable Register)</strong>
* Controls output enable and polarity for timer channels.</p></li>
<li><p><strong>ARR (Auto-Reload Register)</strong>
* Sets the timer’s period and thus the PWM signal’s frequency.</p></li>
<li><p><strong>PSC (Prescaler)</strong>
* Divides the timer clock to adjust the timer’s frequency and PWM period.</p></li>
<li><p><strong>TIM_CR1_CMS (Center-Aligned Mode Selection)</strong>
* Selects between center-aligned and edge-aligned modes for the timer.</p></li>
</ul>
</section>
<section id="id2">
<h3><span class="section-number">3.3.5.8. </span>Summary<a class="headerlink" href="#id2" title="Link to this heading"></a></h3>
<p>This document covers configuring PWM on STM32 microcontrollers, including clock enablement, GPIO setup, and PWM mode selection. It details how to set PWM frequency using prescaler and ARR values, and adjust duty cycle with the CCR register. An example demonstrates configuring TIM3 for a specific frequency and duty cycle.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="vmodel.html" class="btn btn-neutral float-left" title="3.2. SDLC V-Model" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="build_process.html" class="btn btn-neutral float-right" title="3.4. The Build Process" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Maasu BH d.o.o..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>